# 「最早預約」與「已合併」邏輯說明

**版本：** v2.1 Final
**日期：** 2025-12-01

---

## 📋 核心概念

### **「活躍預約中的最早」**

- **活躍預約** = 可能發送簡訊的預約
  - ✅ 未發送（`smsStatus === ''`）
  - ✅ 排程中（`smsStatus === 'scheduled'`）
  - ✅ 發送失敗（`smsStatus === 'failed'`）

- **已失效預約** = 不會再發送簡訊的預約
  - ❌ 已取消（`smsStatus === 'cancelled'`）
  - ❌ 已送達（`smsStatus === 'delivered'`）
  - ❌ 已過期（`isAppointmentExpired === true`）

### **判斷邏輯**

1. 找出同會員、同日期的所有預約
2. **排除已失效的預約**（已取消、已送達、已過期）
3. 在剩餘的「活躍預約」中，找出時間最早的
4. 只有「活躍預約中最早的」可以操作
5. 其他活躍預約顯示「已合併」

---

## 🎯 實際案例

### **案例 1：所有預約都生效**

#### **初始狀態**
```
王大明 - 2025/11/02
├─ 09:00 未發送  ← 活躍預約中的最早 ✅ 可操作
├─ 14:00 未發送  ← 活躍但非最早 ❌ 已合併
└─ 16:00 未發送  ← 活躍但非最早 ❌ 已合併
```

**邏輯：**
- 3 個都是活躍預約（都可能發送）
- 09:00 最早 → 可操作
- 14:00、16:00 非最早 → 已合併

---

### **案例 2：最早預約被取消**

#### **操作：取消 09:00**

#### **結果**
```
王大明 - 2025/11/02
├─ 09:00 已取消  ← 已失效，不參與判斷
├─ 14:00 未發送  ← 現在是活躍中最早 ✅ 可操作（自動補位）
└─ 16:00 未發送  ← 活躍但非最早 ❌ 已合併
```

**邏輯：**
- 09:00 已取消 → 失效，排除
- 剩餘活躍：14:00、16:00
- 14:00 現在是活躍中最早 → 自動變為可操作 ✅
- 16:00 仍非最早 → 繼續已合併

---

### **案例 3：最早預約已送達**

#### **操作：發送 09:00**

#### **8秒後狀態**
```
王大明 - 2025/11/02
├─ 09:00 已送達  ← 已失效，不參與判斷
├─ 14:00 未發送  ← 現在是活躍中最早 ✅ 可操作
└─ 16:00 未發送  ← 活躍但非最早 ❌ 已合併
```

**邏輯：**
- 09:00 已送達 → 失效，排除
- 剩餘活躍：14:00、16:00
- 14:00 現在是活躍中最早 → 可操作
- 16:00 仍非最早 → 已合併

**注意：** 這種情況在實務中較少見（為什麼已經發送過還要再發？），但邏輯上支持。

---

### **案例 4：逐個發送的連鎖反應**

#### **步驟 1：初始**
```
09:00 未發送 ✅  |  14:00 已合併 ❌  |  16:00 已合併 ❌
```

#### **步驟 2：發送 09:00**
```
09:00 排程中 ✅  |  14:00 已合併 ❌  |  16:00 已合併 ❌
```

#### **步驟 3：8秒後，09:00 送達**
```
09:00 已送達 (失效)  |  14:00 可操作 ✅  |  16:00 已合併 ❌
```

#### **步驟 4：發送 14:00**
```
09:00 已送達  |  14:00 排程中 ✅  |  16:00 已合併 ❌
```

#### **步驟 5：8秒後，14:00 送達**
```
09:00 已送達  |  14:00 已送達  |  16:00 可操作 ✅
```

**最終：** 16:00 成為唯一活躍預約，自動可操作。

---

## 🔄 情境 5（自動補位）的實現

### **觸發時機**
用戶點擊「取消」最早預約時

### **檢測邏輯**
```javascript
function cancelSms(appointmentId) {
    // 1. 檢測同日是否有其他「活躍」預約
    const sameDayApts = getSameDayAppointments(...);

    if (sameDayApts.length > 0) {
        // 2. 有其他活躍預約 → 顯示補位彈窗
        const nextAppointment = sameDayApts[0]; // 次早預約
        showReplacementModal(..., nextAppointment, ...);
    } else {
        // 3. 無其他活躍預約 → 標準取消流程
        showStandardCancelModal(...);
    }
}
```

### **補位彈窗顯示**
- **情境 5 警告**：自動補位通知
- **預約列表**：顯示補位預約和其他預約
- **簡訊內容**：自動切換到補位預約的內容
- **用戶操作**：
  - 確認發送 → 原預約「已取消」+ 補位預約「排程中」
  - 不發送 → 僅原預約「已取消」

---

## 📊 判斷流程圖

```
載入預約 → 渲染表格
    ↓
對每個預約執行 generateActionButtons()
    ↓
檢查是否過期？
    YES → 顯示「已過期」，不可操作
    NO ↓
    ↓
查找同日「活躍」預約
getSameDayAppointments()
    ↓
    排除：已取消、已送達、已過期
    保留：未發送、排程中、失敗
    ↓
有同日活躍預約？
    NO → 顯示正常狀態，可操作
    YES ↓
    ↓
當前是活躍中最早？
    YES → 顯示正常狀態，可操作 ✅
    NO → 顯示「已合併」，不可操作 ❌
```

---

## 🧪 測試案例總結

### **測試 1：初始狀態（3個未發送）**
- 09:00 → 可操作 ✅
- 14:00 → 已合併 ❌
- 16:00 → 已合併 ❌

### **測試 2：取消最早**
- 取消 09:00
- 彈出補位彈窗（情境 5）
- 確認後：
  - 09:00 → 已取消
  - 14:00 → 排程中 ✅（自動補位）
  - 16:00 → 已合併 ❌

### **測試 3：次早也取消**
- 取消 14:00
- 彈出補位彈窗
- 確認後：
  - 09:00 → 已取消
  - 14:00 → 已取消
  - 16:00 → 排程中 ✅（再次補位）

### **測試 4：最早已送達**
- 發送 09:00 → 排程中 → 已送達
- 表格重新渲染：
  - 09:00 → 已送達
  - 14:00 → 可操作 ✅（自動解除合併）
  - 16:00 → 已合併 ❌

---

## 💡 關鍵理解

### **「最早」不是固定身份，而是動態計算**

❌ **錯誤理解：**
> 09:00 永遠是最早預約，即使已取消，其他預約也不能發送

✅ **正確理解：**
> 09:00 在活躍時是最早預約，一旦失效（取消/送達），次早預約自動成為「活躍中的最早」

### **業務規則的正確表述**

> **「同一天只發送一封簡訊，以活躍預約中時間最早的為準」**

- 如果最早的被取消 → 次早的補位
- 如果最早的已送達 → 已完成任務，次早的可以操作
- 符合實際業務需求：不會因為最早的被取消而導致客戶收不到通知

---

## 🎯 為什麼這樣設計？

### **場景 1：用戶手誤取消**
```
用戶誤操作取消了 09:00 的簡訊
→ 系統自動提供補位選項（14:00）
→ 客戶仍能收到通知 ✅
```

### **場景 2：預約時間調整**
```
客戶取消了 09:00 預約，改為 14:00
→ 09:00 簡訊取消
→ 14:00 自動可發送 ✅
→ 客戶收到正確時間的通知 ✅
```

### **場景 3：系統已發送後**
```
09:00 簡訊已送達
→ 客戶又新增了 14:00 預約
→ 14:00 可以單獨發送提醒 ✅
→ 不受已送達的 09:00 影響
```

---

## ✅ 總結

### **核心邏輯**
1. **只計算「活躍」預約**（未發送、排程中、失敗）
2. **排除「已失效」預約**（已取消、已送達、已過期）
3. **活躍中最早的可操作**，其他顯示「已合併」
4. **狀態改變時自動重新計算**

### **符合業務需求**
✅ 避免重複發送（同日多個活躍預約時）
✅ 支援補位機制（最早的失效後）
✅ 符合實際操作流程
✅ 用戶體驗良好

---

**這就是完整的「最早預約」邏輯！** 🎉
